#include "shapes3.inc"
#declare pseed = seed(1);


// This file defines macros that create and join segments of pipe to form plumbing.
// Each macro call creates a new segment and joins to the end of the previous.
// Segments are straight (plumb_tube*) or curved (plumb_left/right).
// At first the pipe can only wind around on the Y plane,
//  but you can change the notion of "up" for the "left/right" macros with plumb_twist.
// The radius is carried in a variable to save passing it to each macro,
//  but you can change it with "thinner" and "radstep*"

// Start an array of [n] pipes, each of radius [rad]
#macro plumb_start_n(n, rad)
  #declare plumb_moves_accum = array[n];
  #declare plumb_rad = array[n];
  #for (i, 0, n-1)
    #declare plumb_rad[i] = rad;
    #declare plumb_moves_accum[i] = transform {};
  #end
#end

// Directly set the transformation required to get to this part of the pipe.
// Generally used for parts 2..n of a gang.
#macro plumb_transform_n(n, xform)
  #declare plumb_moves_accum[n] = transform { xform plumb_moves_accum[n]}
#end

// Straight tube, no change in radius, on vector z.
#macro plumb_tube_n(n, zed)
  cylinder {0, zed*z, plumb_rad[n] transform plumb_moves_accum[n]}
  #declare plumb_moves_accum[n] = transform { translate zed*z plumb_moves_accum[n]}
#end

// Cone, changing pipe from one radius to another over a distance zed.
// You know where you can stick your complaint about the name.
#macro plumb_thinner_n(n, radto, zed)
  cone {0, plumb_rad[n], zed*z, radto transform plumb_moves_accum[n]}
  #declare plumb_rad[n] = radto;
  #declare plumb_moves_accum[n] = transform { translate zed*z plumb_moves_accum[n]}
#end

// +ve means anticlockwise, if the rest of the tube is behind us.
// Point your left thumb in the direction of the pipe, fingers curl +ve.
#macro plumb_twist_n(n, ang)
  #declare plumb_moves_accum[n] = transform { rotate ang*z plumb_moves_accum[n]}
#end  

// turn left ang degrees around a major radius.
// If major==0, use a radius that translates forward the pipe radius in a 45 degree turn.
// In that way, a left and a right with major==0 moves the pipe forward double its radius.
// That makes it easier to compute the z-size of a pipe with a dog-leg in it.
#macro plumb_left_n(n, ang, major)
  #if (major=0) #local major=sqrt(2)*plumb_rad[n]; #end
  // Segment_of_Torus:  starts at x=major, y=z=0, goes toward +z (anticlockwise) with -ang < 0
  object {Segment_of_Torus (major, plumb_rad[n], -ang) translate <-major, 0, 0> transform plumb_moves_accum[n]}
  #declare plumb_moves_accum[n] = transform {
    translate <major, 0, 0> rotate <0, -ang, 0> translate <-major, 0, 0>
    plumb_moves_accum[n]
  }
#end

#macro plumb_right_n(n, ang, major)
  #if (major=0) #local major=sqrt(2)*plumb_rad[n]; #end
  object { Segment_of_Torus (major, plumb_rad[n], -ang) translate <-major, 0, 0> scale <-1, 1, 1>  transform plumb_moves_accum[n]}
  #declare plumb_moves_accum[n] = transform {
    translate <-major, 0, 0> rotate <0, ang, 0> translate <major, 0, 0>
    plumb_moves_accum[n]
  }
#end

// plumb_radstep_n changes pipe radius without adding any length.
// A torus that smooths the transition extends into the smaller pipe's space
// (and into the larger pipe's space equally, but inside that pipe).
#macro plumb_radstep_n(n, radto, minor_rad, muffler_p)
// radto is the radius to change to
// minor_rad is the radius of the smoothing on the rim of the bigger pipe/
//  If zero, pick a sensible default.
// muffler_p is a string.  If not "y", draw a disc on the smaller-radius side
//  of the smoothing torus so that it forms a curved edge to the bigger pipe.
//  Otherwise, the sides of a cylinder roll over onto the ends, like an old muffler.
  #local Bigrad = max(plumb_rad[n], radto);
  #if (minor_rad = 0)
    #if (muffler_p = "y")
      #local Minorrad = Bigrad / 10;
    #else
      #local Minorrad = Bigrad / 20;
    #end
  #else
    #local Minorrad = minor_rad;
  #end
  torus {Bigrad - Minorrad, Minorrad rotate 90*x
    transform plumb_moves_accum[n]
  }
  #if (muffler_p != "y")
    disc {0, z, Bigrad-Minorrad
      translate sgn(plumb_rad[n] - radto) * Minorrad*z
      transform plumb_moves_accum[n]
    }
  #end
  #declare plumb_rad[n] = radto;
#end


#macro plumb_splines_n(n, zed, num_splines, radratio, ang_offset)
// Not what you think.  More like splines on a drive shaft.
// Does not shift the plumbing at all - just adds splines around it.
difference{
union {
  #for (i, 0, num_splines-1)
  object {
    Segment_of_CylinderRing(plumb_rad[n]*radratio, 0, zed, 360/num_splines/2)
    rotate <90, 0, 0>
    translate <-plumb_rad[n], 0, 0> rotate <rand(pseed)*2, rand(pseed)*2, 0> translate <plumb_rad[n], 0, 0>
#if (0)
    box {0, <plumb_rad[n]/5, plumb_rad[n]/2, zed>
         translate <0, plumb_rad[n], 0>
  #end
         rotate ((360 / num_splines * i) + ang_offset) * z
         }
#end
} // union
  // subtract away the interior, otherwise it looks like a sunburst
  cylinder{<0, 0, -zed*1.1>, <0, 0, zed*1.1>, plumb_rad[n]*0.8}
  transform plumb_moves_accum[n]
}
#end

// Ribs in the pipe.  Increasing from the radius, like it's been inflated.
// Each rib swells out to radius + radius*bumpratio
#macro plumb_ribs_out_n(n, zed, num_ribs, bumpratio)
#if (num_ribs < 1)
# error concat("I need ribs.  n:", str(n,0,0),
    " zed:", str(zed,0,0),
    " num_ribs:", str(num_ribs,0,0),
    " bumpratio:", str(bumpratio,0,0))
#end
isosurface {
  function { sqrt(y*y+x*x)  // radius of the rendered pipe...
               + cos(z/zed*num_ribs*2*pi) * plumb_rad[n] * bumpratio/2 // ...plus cosine
               - plumb_rad[n]*(1+bumpratio/2) }  // ...equals expanded radius
  contained_by {box {<-plumb_rad[n]*(1.1+bumpratio), -plumb_rad[n]*(1.1+bumpratio), 0>,
                     <plumb_rad[n]*(1.1+bumpratio), plumb_rad[n]*(1.1+bumpratio), zed>}}
  accuracy 0.005 * plumb_rad[n]
  //max_gradient 0.06 // For bumpratio 1, 1+0.6*num_ribs-1
  evaluate 1*0.6,  sqrt(1/(1*0.6)),  0.7
  transform plumb_moves_accum[n]
}
#declare plumb_moves_accum[n] = transform { translate zed*z plumb_moves_accum[n]}
#end

// Ribs in the pipe.  Reducing the radius, like it's been gripped.
// Each corrugation goes in to radius - radius*bumpratio
#macro plumb_ribs_in_n(n, zed, num_ribs, bumpratio)
isosurface {
  function { sqrt(y*y+x*x)
             - cos(z/zed*num_ribs*2*pi)*plumb_rad[n]*bumpratio/2
             - plumb_rad[n]*(1-bumpratio/2) }
  // expand the container to fit inaccuracies
  contained_by {box {<-plumb_rad[n]*1.01, -plumb_rad[n]*1.01, 0>,
                     <plumb_rad[n]*1.01, plumb_rad[n]*1.01, zed>}}
  evaluate 1*0.6,  sqrt(1/(1*0.6)),  0.7
  transform plumb_moves_accum[n]
}
#declare plumb_moves_accum[n] = transform { translate zed*z plumb_moves_accum[n]}
#end

#macro plumb_spiral_para_n(n, zed, num_turns, major)
parametric{
  function{ plumb_rad[n] * cos(u) + major * cos(v/zed*num_turns*2*pi) } // x(u,v)
  function{ plumb_rad[n] * sin(u) + major * sin(v/zed*num_turns*2*pi) }   // y(u,v)
  function{ v }        // z(u,v)
  <0,0>, <2*pi, zed>  // start, end(u,v)
  contained_by {box {<-plumb_rad[n] - major*1.2, -plumb_rad[n] - major*1.2, 0>,
                     <plumb_rad[n] + major *1.2, plumb_rad[n] + major *1.1, zed>}}
  max_gradient 0.00000001 ///...seems to work
  accuracy 0.001 // * plumb_rad[n] ?
  precompute 20 x,y,z
  transform plumb_moves_accum[n]
}
#declare plumb_moves_accum[n] = transform { translate zed*z plumb_moves_accum[n]}
#end

#macro plumb_spiral_n(n, zed, num_turns, major)
isosurface {
  function { 
    f_helix1( x,y,z,
        1,    // number of helixes, (1 = single helix, 2 = double helix etc.)
        num_turns*2*pi,// For number N of turns per heigth of y = 1 unit, use N* 2*pi
        plumb_rad[n], // minor radius,
        major, // major radius,
        1,    // shape parameter,
        0.3,  // cross section type,
              // (0.0 to 1.0 = square ... rounded to circle
              // over 2.0 to 3.0 = rounded to diamond and concave diamond
        0 )   // cross section rotation angle
    }
  // expand the container to fit inaccuracies
  contained_by {box {<-plumb_rad[n]*1.01, -plumb_rad[n]*1.01, 0>,
                     <plumb_rad[n]*1.01, plumb_rad[n]*1.01, zed>}}
  evaluate 1*0.6,  sqrt(1/(1*0.6)),  0.7
  transform plumb_moves_accum[n]
}
#declare plumb_moves_accum[n] = transform { translate zed*z plumb_moves_accum[n]}
#end

//---------



#macro plumb_start(rad) plumb_start_n(1, rad) #end

#macro plumb_transform() plumb_moves_accum[0] #end

#macro plumb_tube(zed) plumb_tube_n(0, zed) #end

#macro plumb_thinner(zed, radto) plumb_thinner_n(0, zed, radto) #end

#macro plumb_twist(ang) plumb_twist_n(0, ang) #end

#macro plumb_left(major, ang) plumb_left_n(0, major, ang) #end

#macro plumb_right(major, ang) plumb_right_n(0, major, ang) #end

